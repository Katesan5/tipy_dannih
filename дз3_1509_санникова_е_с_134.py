# -*- coding: utf-8 -*-
"""ДЗ3-1509_Санникова Е.С_134

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d16qQ5XLNovwYWt_Qnk_OHxVIUT56w1V

# Работа ссылок в питоне:
"""

print ('Пример 1')
a = [1, 2, 3]
b = a
c = a.copy()

print(id(a) == id(b)) # True, так как b — это ссылка на тот же объект, что и a
print(id(a) == id(c)) # False, так как c — это новый объект, созданный копированием a

b.append(4)
print(a)


print ('Пример 2')
a = [1, 2, 3]
print(id(a))  # Например, 135324573712320

a.append(4)
print(id(a))  # Тот же идентификатор, 135324573712320, несмотря на изменение содержимого


print ('Пример 3')
def modify_list(lst):
    print("ID внутри функции (до изменения):", id(lst))
    lst.append(4)
    print("ID внутри функции (после изменения):", id(lst))

a = [1, 2, 3]
print("ID до вызова функции:", id(a))
modify_list(a)
print("ID после вызова функции:", id(a)) # Резюме - один и тот же id. Работаем с одним и тем же объектом a

"""# Работа с оператором *is* и его основные особенности:"""

print ('Пример 1')
x = None
if x is None:
    print("x is None")

print ('Пример 2')
a = 257
b = 257
print(a is b)  # False, даже если a == b

print ('Пример 3')
a = 1
b = 1
print(id(a))
print(id(b))
print(a is b)

print ('Пример 4')
a = 257
b = 257
print(id(a))
print(id(b))
print(a is b) # потому что в python экспериментальным путем 'зарезервировали' значения от -5 до 255

print ('Пример 5')
a = 255
b = 255
print(a is b)  # True, потому что обе переменные ссылаются на один и тот же объект в памяти

c = 257
d = 257
print(c is d)  # False в большинстве реализаций Python, потому что числа за пределами диапазона -5..256 создаются отдельно

"""# Строки и действия с ними:"""

greeting = "Hello" + " " + "World" # конкатенация
greeting

repeated = "ha" * 3  # повторение строк
repeated

char = greeting[1]  # доступ по индексу
char

slicing = greeting[1:4]  # срезы
slicing

"""## Поиск и замена строк:"""

print ('Пример 1')
text = "Hello, world! World is big."
position = text.find("world")
print(position)  # 7


print ('Пример 2')
position = text.rfind("world")
print(position)  # 14


#print ('Пример 3')
#position = text.index("mars")
#print(position)  # ValueError


print ('Пример 4')
position = text.rindex("world")
print(position)  # 14


print ('Пример 5')
new_text = text.replace("world", "planet")
print(new_text)  # "Hello, planet! World is big."
limited_replace = text.replace("World", "planet", 1)
print(limited_replace)  # "Hello, planet! World is big."

# Проверка строк:

print ('Пример 1')
if "подстрока" in "строка":
  print("Подстрока найдена!")


print ('Пример 2')
s = "Привет, мир!"
print(s.startswith("Привет"))  # True
print(s.endswith("!"))         # True


print ('Пример 3')
s1 = "12345"
s2 = "abc"
print(s1.isdigit())  # True, если все символы - цифры
print(s2.isalpha())  # True, если все символы - буквы

# Разбитие строк:

print ('Пример 1')
s = "один,два,три"
parts = s.split(",")  # ['один', 'два', 'три']
print (s)


print ('Пример 2')
s = "один\nдва\nтри"
lines = s.splitlines()  # ['один', 'два', 'три']
print (s)


print ('Пример 3')
s = "один-два-три"
parts = s.partition("-")  # ('один', '-', 'два-три')
print (s)


print ('Пример 4')
s = "один-два-три"
parts = s.rsplit("-", 1)  # ['один-два', 'три']
print (s)

# Объединение строк:
parts = ['один', 'два', 'три']
s = "-".join(parts)  # 'один-два-три'
print (s)

"""## Оптимизация строк:"""

print ('Пример 1')
a = "hello"
b = "hello"
print(a is b)  # True, потому что Python повторно использует одну и ту же строку из-за интернирования



print ('Пример 2')
a = "hello"
b = "hello"
print(a is b)  # True, потому что строки интернированы

c = "hello, world!"
d = "hello, world!"
print(c is d)  # False, потому что более сложные строки обычно не интернируются

e = "_private_var"
f = "_private_var"
print(e is f)  # True



print ('Пример 3')
import time
# Плохой способ конкатенации большого количества строк
start = time.time()
result = ""
for i in range(10**7): # 10000000
    result += str(i)

print(f'Время работы - {time.time() - start}c.')



print ('Пример 4')
# Хороший способ конкатенации большого количества строк
start = time.time()
result = ''.join(str(i) for i in range(10**7))
print(f'Время работы - {time.time() - start}с.')

"""# Списки и методы списка:"""

print ('Пример 1')
lst = [1, 2, 3]
lst.append(4)  # [1, 2, 3, 4]
print (lst)


print ('Пример 2')
lst = [1, 2, 3]
lst.extend([4, 5])  # [1, 2, 3, 4, 5]
print (lst)


print ('Пример 3')
lst = [1, 3, 4]
lst.insert(1, 2)  # [1, 2, 3, 4]
print (lst)


print ('Пример 4')
lst = [1, 2, 3, 2]
lst.remove(2)  # [1, 3, 2]
print (lst)


print ('Пример 5')
lst = [1, 2, 3]
lst.pop()  # 3, lst становится [1, 2]
print (lst)


print ('Пример 6')
lst = [1, 2, 3, 2]
lst.index(2)  # 1
print (lst)



print ('Пример 7')
lst = [1, 2, 3, 2]
lst.count(2)  # 2
print (lst)



print ('Пример 8')
lst = [3, 1, 2]
lst.sort()  # [1, 2, 3]
print (lst)


print ('Пример 6')
lst = [1, 2, 3]
lst.reverse()  # [3, 2, 1]
print (lst)


print ('Пример 10')
lst = [1, 2, 3]
lst.clear()  # []
print (lst)

"""## Примеры кода работы со списками:"""

print ('Пример 1')
# Создание и модификация списка

items = [1, 2, 3]
print(id(items))  # например, 135323731258624

items.append(4)
print(id(items))  # все еще 135323731258624, несмотря на изменение содержимого


print ('Пример 2')
# Ссылочное поведение

a = [1, 2, 3]
b = a  # b ссылается на тот же список, что и a

b.append(4)
print(a)  # [1, 2, 3, 4] — изменения в b отразились на a
print('-' * 12)
c = a.copy()  # создаем копию списка
c.append(5)
print(a)  # [1, 2, 3, 4] — a не изменился, так как c — это отдельный объект


print ('Пример 3')
# Изменяемые типы - очень опасно!

lst = [[1, 1, 1]] * 3 # Создали матрицу состоящую из единиц
print(lst)
lst[0][0] = 9 # Изменили первое значение в первом списке
print(lst) # Меняется везде! Потому что список - это упорядоченный набор объектов [ссылок на них]


print ('Пример 4')
def foo(a:int, b=[]):
  b.append(a)
  print(a, b)

foo(2)


print ('Пример 5')
foo(3)


print ('Пример 6')
lst = [1, 2, 3, 4, 5]

for value in lst:
  print(value)

# versus

for index in range(len(lst)):
  print(lst[index])

# versus

for index, value in enumerate(lst):
  print(f"{index}: {value}")

print ('Пример 1')
# Добавление элементов в конец списка
lst = []
for i in range(10000):
    lst.append(i)  # O(1) для каждой операции, итоговая сложность O(n)
print (lst)


print ('Пример 2')
# Добавление элементов в начало списка
lst = []
for i in range(10000):
    lst.insert(0, i)  # O(n) для каждой операции, итоговая сложность O(n^2)
print (lst)


print ('Пример 3')
a = list(range(5000))
k = 1239 # хотим найти этот элемент

for i in a:
  if i == k:
    print('Find') # 0(n)
print (lst)

print ('Пример 1')
squared_numbers = [x**2 for x in range(10)]
print (squared_numbers)

print ('Пример 2')
# Условные выражения

even_squares = [x**2 for x in range(10) if x % 2 == 0]
print (even_squares)


print ('Пример 3')
# Внутри можем использовать также функции

words = ["hello", "world"]
lengths = [len(word) for word in words]
print (lengths)

"""# Кортежи и работа с ними:"""

print ('Пример 1')
person = ("John", "Doe", 30)  # имя, фамилия, возраст
print (person)


print ('Пример 2')
"""Несмотря на то что кортежи являются неизменяемыми,
объекты внутри них могут быть изменены,
если они сами по себе изменяемы"""


t = ([1, 2], [3, 4])
t[0].append(5)  # Допустимо, потому что список внутри кортежа изменяем
print(t)  # Вывод: ([1, 2, 5], [3, 4])


print ('Пример 3')
# кортеж с одним элементом

single = (5)  # Обратите внимание на запятую!
print(type(single))
single = (5, )
print(type(single))


#print ('Пример 4')
#lst = [i for i in range(10**5)]
#tup = tuple(i for i in range(10**5))

#print(f'Список - {getsizeof(lst)}')
#print(f'Кортеж - {getsizeof(tup)}' )


print ('Пример 5')
t = ([1, 2], [3, 4])
print(id(t))
print('-' * 30)
print(id(t[0]))

t[0].append(5)
print(id(t[0]))
print('-' * 30)
print(id(t)) # id сохранился. Даже после изменения в нем объекта


print ('Пример 6')
example_tuple = (1, 2, 3, 4, 5)

for value in example_tuple:
  print(value)

for index in range(len(example_tuple)):
  print(example_tuple[index])

for index, value in enumerate(example_tuple):
  print(f"{index}: {value}")